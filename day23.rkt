(define (parse input)
  (let ([s (mutable-set)])
    (for ([i (in-range (length input))])
         (for ([j (in-range (string-length (car input)))])
              (when (char=? (string-ref (list-ref input i) j) #\#)
                (set-add! s (list j i)))))
    s))

(define (array+ . args) (apply (curry map +) args))
(define (rotate l) (append (cdr l) (list (car l))))
(define dirs-all '((-1 -1) (0 -1) (1 -1) (-1  0) (1  0) (-1  1) (0  1) (1  1)))
(define dirs-card '((0 -1) (0 1) (-1 0) (1 0)))
(define preds (list (lambda (p) (= (cadr p) -1)) (lambda (p) (= (cadr p)  1))
                    (lambda (p) (= (car  p) -1)) (lambda (p) (= (car  p)  1))))
(define (get-positions p pred) (map (curry array+ p) (filter pred dirs-all)))
(define (all _) #t)
(define (no-elfs? pos grid pred)
  (not (ormap (curry set-member? grid) (get-positions pos pred))))

(define (get-dir pos grid dirs)
  (if (no-elfs? pos grid all)
    '(0 0)
    (let ([d (findf (lambda (dir) (no-elfs? pos grid (list-ref preds dir))) dirs)])
      (if d (list-ref dirs-card d) '(0 0)))))

(define (proposed-positions grid directions)
  (foldl (lambda (p h) (hash-update h (array+ p (get-dir p grid directions))
                                    (lambda (l) (cons p l)) '()))
         (hash) (set->list grid)))

(define (step grid directions)
  (foldl (lambda (p s)
           (let ([pos (car p)] [elfs (cdr p)])
             (if (= (length elfs) 1)
               (set-add s pos)
               (foldl (lambda (elf s) (set-add s elf)) s elfs))))
         (set)
         (hash->list (proposed-positions grid directions))))

(define (count-grid sr er sc ec count?)
  (let ([sum 0])
    (for ([r (in-range sr (+ 1 er))])
         (for ([c (in-range sc (+ 1 ec))])
              (when (count? c r)
                (set! sum (add1 sum)))))
    sum))

(define (count-empty grid [l (set->list grid)])
  (count-grid (apply min (map cadr l)) (apply max (map cadr l))
              (apply min (map car  l)) (apply max (map car  l))
              (lambda (r c) (not (set-member? grid (list r c))))))

(define (sim-rounds input n f)
  (foldl (lambda (x r) (begin (f r) (list (apply step r) (rotate (cadr r)))))
         (list input (range 4)) (range n)))

(define (part1 input)
  (println (count-empty (car (sim-rounds input 10 identity)))))

(define input1 (parse (file->lines "input23-1.txt")))
(define input2 (parse (file->lines "input23-2.txt")))
(define input3 (parse (file->lines "input23-3.txt")))
(part1 input1)
(part1 input2)
(part1 input3)
