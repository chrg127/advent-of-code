(define (ints s) (map string->number (regexp-match* "[-?0-9]+" s)))
(define (radiuses x)
  (list (car x) (apply manhattan x)))
(define (parse input)
  (map (compose radiuses (lambda (x) (list (take x 2) (drop x 2))) ints) input))

(define (array+ . args) (apply (curry map +) args))
(define (array- . args) (apply (curry map -) args))
(define (array-abs . args) (apply (curry map abs) args))
(define (manhattan x y) (apply + (array-abs (array- x y))))
(define (between x a b) (and (<= x b) (>= x a)))
(define (tuning-freq x y) (+ y (* x 4000000)))
(define (inv-man x1 y1 y2 r)
  (if (not (between y2 (- y1 r) (+ y1 r)))
    '()
    (list (max (+ (- r)    y1  (- y2) x1)
               (+ (- r) (- y1)    y2  x1))
          (min (+    r     y1  (- y2) x1)
               (+    r  (- y1)    y2  x1)))))
(define ((xs-of y) sensor r)
  (inv-man (car sensor) (cadr sensor) y r))

(define (part1 input y)
  (let ([r (apply append (map (lambda (p) (apply (xs-of y) p)) input))])
    (println (- (apply max r) (apply min r)))))

(define (covered? p sensors limit)
  (if (and (between (car  p) 0 limit) (between (cadr p) 0 limit))
    (ormap (lambda (s) (<= (manhattan (car s) p) (cadr s))) sensors)
    #t))

(define (y-loop c r f [rr (+ r 1)])
  (let* ([y-start (- (cadr c) rr)] [y-end (+ (cadr c) rr 1)])
    (ormap (lambda (y) (apply f (append (list y) ((xs-of y) c rr))))
           (range y-start y-end))))

(define ((find-point sensors limit) y x1 x2)
  (cond ((not (covered? (list x1 y) sensors limit)) (list x1 y))
        ((not (covered? (list x2 y) sensors limit)) (list x2 y))
        (else #f)))

(define (part2 input limit)
  (println (apply tuning-freq
                  (ormap (lambda (s)
                           (y-loop (car s) (cadr s) (find-point input limit))) input))))

(define input1 (parse (file->lines "input15-1.txt")))
(define input2 (parse (file->lines "input15-2.txt")))
(time (part1 input1 10))
(time (part1 input2 2000000))
(time (part2 input1 20))
(time (part2 input2 4000000))
