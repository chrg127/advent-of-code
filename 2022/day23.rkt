(define (parse input)
  (let ([s (mutable-set)])
    (for ([i (in-range (length input))])
         (for ([j (in-range (string-length (car input)))])
              (when (char=? (string-ref (list-ref input i) j) #\#)
                (set-add! s (list j i)))))
    s))

(define (array+ . args) (apply (curry map +) args))
(define (rotate l) (append (cdr l) (list (car l))))
(define dirs-all '((-1 -1) (0 -1) (1 -1) (-1  0) (1  0) (-1  1) (0  1) (1  1)))
(define dirs-card '((0 -1) (0 1) (-1 0) (1 0)))
(define (mkpred f n) (lambda (p) (= (f p) n)))
(define preds (list (mkpred cadr -1) (mkpred cadr 1) (mkpred car -1) (mkpred car 1)))
(define (get-positions p pred) (map (curry array+ p) (filter pred dirs-all)))
(define (all _) #t)
(define (no-elfs? pos grid pred)
  (not (ormap (curry set-member? grid) (get-positions pos pred))))

(define (get-dir pos grid dirs)
  (if (no-elfs? pos grid all)
    '(0 0)
    (let ([d (findf (lambda (dir) (no-elfs? pos grid (list-ref preds dir))) dirs)])
      (if d (list-ref dirs-card d) '(0 0)))))

(define (proposed-positions grid dirs)
  (foldl (lambda (p h) (hash-update h (array+ p (get-dir p grid dirs))
                                    (lambda (l) (cons p l)) '()))
         (hash) (set->list grid)))

(define (step grid dirs)
  (foldl (lambda (p s) (let ([pos (car p)] [elfs (cdr p)])
                         (if (= (length elfs) 1)
                           (set-add s pos)
                           (foldl (lambda (elf s) (set-add s elf)) s elfs))))
         (set)
         (hash->list (proposed-positions grid dirs))))

(define (count-grid sr er sc ec count?)
  (let ([sum 0])
    (for ([r (in-range sr (+ 1 er))])
         (for ([c (in-range sc (+ 1 ec))])
              (when (count? c r)
                (set! sum (add1 sum)))))
    sum))

(define (count-empty grid [l (set->list grid)])
  (count-grid (apply min (map cadr l)) (apply max (map cadr l))
              (apply min (map car  l)) (apply max (map car  l))
              (lambda (r c) (not (set-member? grid (list r c))))))

(define (sim-rounds cur stop? [rounds 0] [last '()] [dirs (range 4)])
  (if (stop? cur last rounds)
    (list cur rounds)
    (sim-rounds (step cur dirs) stop? (+ 1 rounds) cur (rotate dirs))))

(define (part1 input)
  (println (count-empty (car (sim-rounds input (lambda (c l n) (= n 10)))))))
(define (part2 input)
  (println (cadr (sim-rounds input (lambda (c l n) (equal? c l))))))

(time (begin (define input1 (parse (file->lines "input23-1.txt")))
             (define input2 (parse (file->lines "input23-2.txt")))
             (define input3 (parse (file->lines "input23-3.txt")))
             (part1 input1)
             (part1 input2)
             (part1 input3)
             (part2 input1)
             (part2 input2)
             (part2 input3)))
